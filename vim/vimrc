" ============= SETUP =============

let g:mapleader=' '

" language settings (have to be before ä and ö mappings)
let $LANG='en_US'
set fileformats=unix,dos
set fileencodings=ucs-bom,utf-8,default,latin1
set encoding=utf-8
scriptencoding utf-8


let TempFolder = '/.temp'
let PluginsFolder = '/plugins'
if has('win32')
    let VimFolder = '/vimfiles'
    exe 'set viminfo+=n~' . VimFolder . TempFolder . '/_viminfo'
else
    let VimFolder = '/.vim'
    exe 'set viminfo+=n~' . VimFolder . TempFolder . '/.viminfo'
endif
let PathToTempFolder = $HOME . VimFolder . TempFolder
let PathToPluginsFolder = $HOME . VimFolder . PluginsFolder
let g:netrw_dirhistmax=0

" make sure that the temp file locations exists
for folder in ['/undo', '/backup', '/swap']
    if !isdirectory(PathToTempFolder . folder)
        call mkdir(PathToTempFolder . folder, 'p')
    endif
endfor

" temp file locations
let &undodir = PathToTempFolder . '/undo'
let &backupdir = PathToTempFolder . '/backup'
let &directory = PathToTempFolder . '/swap'



" ============= PLUGINS =============

call plug#begin(PathToPluginsFolder)
if has('win32')
    Plug 'Yggdroot/LeaderF', { 'do': '.\install.bat' }
else
    Plug '/usr/local/opt/fzf'
    Plug 'junegunn/fzf.vim'
endif
Plug 'terryma/vim-smooth-scroll'       " smooth scrolling
Plug 'machakann/vim-highlightedyank'   " highlight yanks
Plug 'markonm/traces.vim'              " live substitution

Plug 'easymotion/vim-easymotion'       " jump to any position
Plug 'simnalamburt/vim-mundo'          " graphical undotree

Plug 'tpope/vim-surround'              " edit braces easily
Plug 'tpope/vim-commentary'            " comment out lines
Plug 'tpope/vim-repeat'                " repeat plugin commands
Plug 'vim-scripts/ReplaceWithRegister' " operator to replace text
Plug 'wellle/targets.vim'              " more text objects
Plug 'tommcdo/vim-exchange'            " change two objects
Plug 'tpope/vim-abolish'               " more advanced substitute etc

Plug 'tpope/vim-eunuch'                " easy unix file operations

Plug 'xuhdev/vim-latex-live-preview', { 'for': 'tex' } " live preview for latex
Plug 'neoclide/coc.nvim', {'branch': 'release'} " language-server plugin

" colorshemes
Plug 'lifepillar/vim-solarized8'
call plug#end()


" neoclide/coc.nvim
set updatetime=300
set signcolumn=auto

inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
inoremap <expr> <TAB> pumvisible() ? "\<C-y>" : "\<TAB>"

nmap <silent> <C-P> <Plug>(coc-diagnostic-prev)
nmap <silent> <C-N> <Plug>(coc-diagnostic-next)

nmap <silent> gd <Plug>(coc-definition)

nmap <silent> <Leader>t <Plug>(coc-type-definition)
nmap <silent> <Leader>i <Plug>(coc-implementation)
nmap <silent> <Leader>u <Plug>(coc-references)
nnoremap <silent> <Leader>d :call <SID>show_documentation()<CR>
nmap <leader>r <Plug>(coc-rename)
xmap <leader>o <Plug>(coc-format-selected)
nmap <leader>o <Plug>(coc-format-selected)
nnoremap <silent> <Leader>o :<C-u>CocList diagnostics<cr>
nnoremap <silent> <Leader>a :<C-u>CocList commands<cr>
nnoremap <silent> <Leader>h :<C-u>CocList outline<cr>
nnoremap <silent> <Leader>s :<C-u>CocList -I symbols<cr>

" mappings for function text objects
xmap if <Plug>(coc-funcobj-i)
xmap af <Plug>(coc-funcobj-a)
omap if <Plug>(coc-funcobj-i)
omap af <Plug>(coc-funcobj-a)

command! -nargs=0 Format :call CocAction('format')
command! -nargs=0 OR :call CocAction('runCommand', 'editor.action.organizeImport')

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocAction('doHover')
  endif
endfunction


" tpope/vim-surround
nmap S ysiW

" xuhdev/vim-latex-live-preview
let g:livepreview_previewer = 'open -a Skim'
let g:livepreview_cursorhold_recompile = 0

if has('win32')
    " Yggdroot/LeaderF
    " Requires ripgrep: https://github.com/BurntSushi/ripgrep
    " A lot faster if the C extension is installed with the install script
    let g:Lf_StlColorscheme='default'
    let g:Lf_CursorBlink=0
    let g:Lf_UseVersionControlTool=0
    let g:Lf_DefaultExternalTool='rg'
    let g:Lf_ShowHidden=1
    let g:Lf_CacheDirectory=PathToTempFolder
    let g:Lf_IndexTimeLimit=600
    let g:Lf_UseCache=1
    let g:Lf_HighlightIndividual=1
    let g:Lf_NumberOfHighlight=100
    let g:Lf_UseMemoryCache=1
    let g:Lf_WildIgnore = {
            \ 'dir': ['.git'],
            \ 'file': []
            \}
    let g:Lf_CommandMap = {'<C-K>': ['<Up>'], '<C-J>': ['<Down>']}
    let g:Lf_ShortcutF='<Leader>f'
    nnoremap <Leader>l :LeaderfLineAll<CR>
    nnoremap <Leader>g :LeaderfHelp<CR>
    nnoremap <Leader>b :LeaderfBufferAll<CR>
    nnoremap <Leader>m :LeaderfMru<CR>
else
    " junegunn/fzf.vim
    nnoremap <Leader>f :Files<CR>
    nnoremap <Leader>l :Lines<CR>
    nnoremap <Leader>g :Helptags<CR>
    nnoremap <Leader>b :Buffers<CR>
    nnoremap <Leader>m :History<CR>
endif

" easymotion/vim-easymotion
let g:EasyMotion_keys='asdghklqwertyuiopzxcvbnmfj'
let g:EasyMotion_do_shade=0
let g:EasyMotion_do_mapping=0
let g:EasyMotion_smartcase=1
map <Leader>k <Plug>(easymotion-bd-f)

" machakann/vim-highlightedyank
let g:highlightedyank_highlight_duration=300

" simnalamburt/vim-mundo
let g:mundo_preview_statusline='Diff'
let g:mundo_tree_statusline='History'
let g:mundo_mirror_graph=0
let g:mundo_return_on_revert=0
let g:mundo_verbose_graph=0
nnoremap <silent> <Leader>n :MundoToggle<CR>

" vim-scripts/ReplaceWithRegister
nmap ö <Plug>ReplaceWithRegisterOperator
nmap Ö <Plug>ReplaceWithRegisterOperator$
nmap öö <Plug>ReplaceWithRegisterLine
xmap ö <Plug>ReplaceWithRegisterVisual

" terryma/vim-smooth-scroll
nnoremap <silent> <C-U> :<C-U>call smooth_scroll#up(&scroll, 0, 4)<CR>
nnoremap <silent> <C-D> :<C-U>call smooth_scroll#down(&scroll, 0, 4)<CR>
nnoremap <silent> <C-B> :<C-U>call smooth_scroll#up(&scroll*2, 0, 6)<CR>
nnoremap <silent> <C-F> :<C-U>call smooth_scroll#down(&scroll*2, 0, 6)<CR>



" ============= GENERAL =============

" set these only when vim starts, not when sourcing vimrc
if !exists('g:notfirstopen')
    let g:notfirstopen=1

    set termguicolors
    set background=dark

    colorscheme solarized8  " messes up Mundo if loaded again

    if has('gui_running')
        set lines=40 columns=120  " initial window size
        if has ('win32')
            " changing font moves the window
            set guifont=Consolas:h12
        else
            set guifont=SFMono-Regular:h16
        endif
    endif

    syntax enable

    highlight Comment term=NONE ctermfg=10 gui=NONE guifg=#586e75
    " make solarized8 terminal and gui cursor the same color
    highlight Cursor ctermfg=15 ctermbg=4 guifg=#073642 guibg=#839496
endif

if has('win32')
    " use git bash as shell
    set shell=C:/Program\ Files/Git/usr/bin/bash.exe\ --login
else
    " use the bash installed with homebrew as shell
    set shell=/usr/local/bin/bash\ --login
endif

set clipboard=unnamed  " use system clipboard, unnamedplus doesn't work with gvim

if has('gui_running')
    " GUI specific settings
    set guioptions=
    " Cursor is a vertical bar in insert mode and a block in normal mode.
    set guicursor+=a:blinkon0
    set guicursor+=i-ci:ver20-blinkon0
else
    " terminal specific settings
    set mouse=a
    if $TERM_PROGRAM =~ "iTerm"
        set ttymouse=sgr
        let &t_SI = "\e[6 q"
        let &t_EI = "\e[2 q"
        let &t_SR = "\e[4 q"
    endif
endif

" visuals
set cursorline
set number relativenumber
set showmode showcmd
set report=1
set cmdheight=2
set hlsearch

" statusline
set laststatus=2                                           " always show statusline
set statusline=                                            " clear statusline
set statusline+=%l                                         " current line number
set statusline+=/%L                                        " total lines
set statusline+=(%p%%)                                     " percentage through the file
set statusline+=%4c                                        " cursor column
set statusline+=\|%-4{strwidth(getline('.'))}              " line length
if has('win32')
    " different separator between current filename and folder for Windows: \ vs *nix: /
    " could maybe be cleaner, but this does the job
    set statusline+=%{&buftype!='terminal'?expand('%:p:h:t').'\\'.expand('%:t'):expand('%')} " dir\filename.ext
else
    set statusline+=%{&buftype!='terminal'?expand('%:p:h:t').'/'.expand('%:t'):expand('%')}  " dir/filename.ext
endif
set statusline+=%m                                         " modified flag
set statusline+=%r                                         " read only flag
set statusline+=%=                                         " left/right separator
set statusline+=\ \|\ %{substitute(getcwd(),$HOME,'~','')} " current working directory
set statusline+=\ [%{strlen(&ft)?(&ft\ .\ \',\'):''}       " filetype
set statusline+=%{strlen(&fenc)?(&fenc\ .\ \',\'):''}      " file encoding
set statusline+=%{&ff}]                                    " line endings
set statusline+=%<                                         " start to truncate here

" line wrapping
set wrap linebreak textwidth=0 wrapmargin=0

" indentation settings
set tabstop=8 softtabstop=4 shiftwidth=4 expandtab
set smarttab  autoindent    breakindent

" show unwanted whitesace on 'set list'
set nolist listchars=tab:>-,trail:.,nbsp:.

" search settings
set incsearch hlsearch ignorecase smartcase gdefault

" no errorbells
set noerrorbells
augroup NoVisualBells
    autocmd!
    autocmd GUIEnter * set visualbell t_vb=
augroup END

" mixed settings
set timeoutlen=1000            " timeout for keymappings
set formatoptions=qlj          " don't autocontinue comment lines, remove comment when joining
set pumheight=12               " max height for the autocompletion popup
set nomodeline                 " don't try to parse commands from opened file
set ttimeoutlen=0              " remove delay from esc
set backspace=indent,eol,start " make backspace behave normally
set hidden                     " switch to another buffer without saving
set autoread                   " update changes to file automatically
set scrolloff=1                " pad cursor row with lines
set splitright                 " open splits to the right
set splitbelow                 " open splits to the bottom
set wildmode=list:longest,full " better tab completion on command line mode
set undofile                   " use an undofile for persistent undo
set undolevels=10000           " remember more undo history
set history=1000               " remember more command history
set updatecount=10             " update swap file more often
set matchpairs=(:),{:},[:]     " configure which braces to match
set shortmess=ac               " shorter prompt messages, no ins completion messages
filetype plugin indent on      " auto detect filetype



" ============= MAPPINGS =============

" make j and k populate the jump list, when used with a count
nnoremap <expr> j (v:count > 1 ? "m'" . v:count : '') . 'j'
nnoremap <expr> k (v:count > 1 ? "m'" . v:count : '') . 'k'

if has('win32')
    " split navigations (alt+hjkl)
    nnoremap è <C-W><C-H>
    nnoremap ê <C-W><C-J>
    nnoremap ë <C-W><C-K>
    nnoremap ì <C-W><C-L>

    " cycle buffers (alt+nm)
    nnoremap <silent> î :bprev<CR>
    nnoremap <silent> í :bnext<CR>

    " cycle tabs (alt+ui)
    nnoremap <silent>õ :tabprevious<CR>
    nnoremap <silent>é :tabnext<CR>

    " toggle fullscreen
    nnoremap <silent> <Leader>0 :<C-U>call libcallnr("gvimfullscreen.dll", "ToggleFullScreen", 0)<CR>

    if has('terminal')
        tnoremap è <C-W><C-H>
        tnoremap ê <C-W><C-J>
        tnoremap ë <C-W><C-K>
        tnoremap ì <C-W><C-L>
        tnoremap <silent> î <C-W>:bprev<CR>
        tnoremap <silent> í <C-W>:bnext<CR>
        tnoremap <silent>õ <C-W>:tabprevious<CR>
        tnoremap <silent>é <C-W>:tabnext<CR>
    endif

    " unmap push-to-talk key
    map <F13> <Nop>
    map! <F13> <Nop>
else
    if has('gui_running')
        " move between splits (alt+hjkl)
        nnoremap ← <C-W>h
        nnoremap ↓ <C-W>j
        nnoremap ↑ <C-W>k
        nnoremap → <C-W>l

        " cycle buffers (alt+nm)
        nnoremap <silent> № :bprev<CR>
        nnoremap <silent> µ :bnext<CR>

        " cycle tabs (alt+ui)
        nnoremap <silent>ü :tabprevious<CR>
        nnoremap <silent>↔︎ :tabnext<CR>

        if has('terminal')
            tnoremap ← <C-W><C-H>
            tnoremap ↓ <C-W><C-J>
            tnoremap ↑ <C-W><C-K>
            tnoremap → <C-W><C-L>
            tnoremap <silent> № <C-W>:bprev<CR>
            tnoremap <silent> µ <C-W>:bnext<CR>
            tnoremap <silent>ü <C-W>:tabprevious<CR>
            tnoremap <silent>↔︎ <C-W>:tabnext<CR>
        endif
    else
        " move between splits (alt+hjkl)
        nnoremap <Esc>h <C-W>h
        nnoremap <Esc>j <C-W>j
        nnoremap <Esc>k <C-W>k
        nnoremap <Esc>l <C-W>l

        " cycle buffers (alt+nm)
        nnoremap <silent> <Esc>n :bprev<CR>
        nnoremap <silent> <Esc>m :bnext<CR>

        " cycle tabs (alt+ui)
        nnoremap <silent> <Esc>u :tabprevious<CR>
        nnoremap <silent> <Esc>i :tabnext<CR>

        if has('terminal')
            tnoremap <Esc>h <C-W><C-H>
            tnoremap <Esc>j <C-W><C-J>
            tnoremap <Esc>k <C-W><C-K>
            tnoremap <Esc>l <C-W><C-L>
            tnoremap <silent> <Esc>n <C-W>:bprev<CR>
            tnoremap <silent> <Esc>m <C-W>:bnext<CR>
            tnoremap <silent> <Esc>u <C-W>:tabprevious<CR>
            tnoremap <silent> <Esc>i <C-W>:tabnext<CR>
        endif
    endif
endif

" makes these easier to use
noremap , :
if has('terminal')
    tnoremap <C-W>, <C-W>:
endif
noremap : ;
noremap ; ,
noremap @, @:
noremap g, g;
noremap g. g,
nnoremap q, q:
xnoremap q, q:
augroup QMappings
    autocmd!
    autocmd FileType * if &buftype ==# 'nofile'|silent! unmap q,|endif
    autocmd BufEnter * if &buftype !=# 'nofile'|nnoremap q, q:|endif
augroup END

" makes these more consistent with other commands
nnoremap Y y$
nnoremap vv V
nnoremap V <C-V>$

" cleaner to use when cursor doesn't move
nnoremap J Jh

" make K the logical opposite of J
nnoremap K a<CR><Esc>k$

" makes using marks a lot better
nnoremap ' `

" select previously yanked text
nnoremap gb `[v`]

" search for selected text
xnoremap <Leader>/ "zy/\V<C-R>=escape(@z,'/\')<CR><CR>

" substitute selected text
xnoremap <Leader>7 "zy:%s/<C-R>=escape(@z,'/\')<CR>/

" change eol comment to line comment and vice versa
" this // is the default version for unspecified filetypes
nnoremap ä :set nohlsearch<CR>$?\v//<CR>gEl"_d/\v\//<CR>"qDO<C-R>q<Esc>^:set hlsearch<BAR>noh<CR>
nnoremap Ä ^"qD"_ddA  <C-R>q<Esc>^

" easy way to run : command again for a visual selection
xnoremap <Leader>, q:<UP>I'<,'><Esc>$

" make C-U and C-W undoable
inoremap <C-U> <C-G>u<C-U>
inoremap <C-W> <C-G>u<C-W>


" change enter behaviour
augroup EnterMappings
    autocmd!
    autocmd BufEnter * if &buftype !=# 'nofile'
            \| nnoremap <buffer> <silent> <CR> :<C-U>call <SID>BlankDown(v:count1)<CR>
            \| nnoremap <buffer> <silent> <S-Enter> :<C-U>call <SID>BlankUp(v:count1)<CR>
            \| endif
    autocmd CmdwinEnter * nnoremap <buffer> <CR> <CR>
augroup END

" move CTRL-I, since tab is taken
nnoremap <C-K> <C-I>

" better way to indent
nnoremap <BS> <<
nnoremap <TAB> >>
xnoremap <BS> <gv
xnoremap <TAB> >gv

" persistent visuals
xnoremap > >gv
xnoremap < <gv
xnoremap <C-X> <C-X>gv
xnoremap <C-A> <C-A>gv

" paste to the next or previous line
nnoremap gp o<Esc>p^
nnoremap gP O<Esc>p^

" Q plays back q macro
nnoremap Q @q

function! s:EscMapping() abort
    nnoremap <silent> <Esc> <Esc>:noh<CR>
endfunction
function! s:SearchMapping() abort
    call <SID>EscMapping()
    unmap n
    unmap N
    unmap /
    unmap ?
    unmap *
    unmap #
endfunction
if has('gui_running')
    call <SID>EscMapping()
else
    nnoremap <silent> n :call <SID>SearchMapping()<CR>n
    nnoremap <silent> N :call <SID>SearchMapping()<CR>N
    nnoremap <silent> * :call <SID>SearchMapping()<CR>*
    nnoremap <silent> # :call <SID>SearchMapping()<CR>#
    nnoremap / :call <SID>SearchMapping()<CR>/
    nnoremap ? :call <SID>SearchMapping()<CR>?
    augroup esc_mapping
      autocmd!
      autocmd InsertEnter * call <SID>EscMapping()
    augroup END
endif

" open vimrc
nnoremap <silent> <Leader>vr :e $MYVIMRC<CR>
nnoremap <silent> <Leader>cr :CocConfig<CR>



" ============= COMMANDS =============

" vim-plug commands
command! PI silent! w | PlugInstall
command! PC silent! w | PlugClean!
" PlugUpgrade breaks vim-plug on windows atm
command! PU w | PlugUpdate
command! PS exec 'PlugSnapshot! ' . PathToPluginsFolder . '/plugins.lock'

" source vimrc
command! SO so $MYVIMRC

" insert contents of command to buffer
command! -nargs=1 RE call RED('<args>')

" change the contents of a register
command! -nargs=1 CR call ChangeReg('<args>')

" count lines in file
command! WC %s/^\s*\w\+//n | noh

" count all .py files lines, have to have terminal open in tab 1 for this to work.
command! PL write|tabn 1|call RunCommandInSplitTerm("grep -vc '^\\s*$' *.py && echo -n 'total:' && grep -v '^\\s*$' *.py | wc -l")

" change working directory to current file's directory
command! CD cd %:p:h|pwd



" ============= FUNCTIONS =============

" https://github.com/dhleong/dots/blob/master/.vim/init/terminal.vim
function! RunCommandInSplitTerm(command) abort
    write
    let winSize = float2nr(0.3 * winheight('$'))
    let mainBuf = bufnr('%')
    let termBufNr = get(b:, '_run_term', -1)
    let termWinNr = bufwinnr(termBufNr)

    if termWinNr == -1
        exe 'below split | resize ' . winSize
        if termBufNr == -1 || bufexists(termBufNr) == 0
            let termBufNr = term_start(&shell, {
                        \ 'curwin': 1,
                        \ 'term_finish': 'close',
                        \ })
            call setbufvar(mainBuf, '_run_term', termBufNr)
        else
            exe 'buffer' . termBufNr
        endif
    else
        exe termWinNr . 'wincmd w'
    endif

    let mainWin = bufwinnr(mainBuf)
    call term_sendkeys(termBufNr, a:command . "\<CR>")
    exe "normal \<C-W>p"
endfunction


" insert blank lines before current line
function! s:BlankUp(count) abort
    norm! mq
    for i in range(a:count)
        exec "norm! O\<Esc>0\"_D"
    endfor
    norm! `q
endfunction


" insert blank lines after current line
function! s:BlankDown(count) abort
    norm! mq
    for i in range(a:count)
        exec "norm! o\<Esc>0\"_D"
    endfor
    norm! `q
endfunction


" redir command's output to the current line
function! RED(command)
    redir => output
    silent exec a:command
    redir END
    let @z = substitute(output, '^\n', '', '')
    execute "put z"
    return ''
endfunction


function! ChangeReg(x) abort
  call feedkeys("q:ilet @" . a:x . " = \<c-r>\<c-r>=string(@" . a:x . ")\<cr>\<esc>0f'", 'n')
endfunction



" ============= AUTOCMD =============

" toggle relative numbers between modes
augroup LineNumbers
    autocmd!
    autocmd WinEnter,FocusGained,InsertLeave * if &l:buftype !=# 'nofile' && &l:buftype !=# 'nowrite' && &l:buftype !=? 'help'|set relativenumber|endif
    autocmd WinLeave,FocusLost,InsertEnter * if &l:buftype !=# 'nofile' && &l:buftype !=# 'nowrite' && &l:buftype !=? 'help'|set norelativenumber|endif
augroup END


" source vimrc when it's saved
augroup ReloadVimrc
    autocmd!
    autocmd BufWritePost *vimrc so $MYVIMRC
augroup END


" open help windows in a new tab
augroup HelpOpen
    autocmd!
    autocmd BufRead *.txt if &buftype ==? 'help'
                    \|exe "normal \<C-W>T"
                \|endif
augroup END


" clear trailing whitespace when saving vimrc
augroup TrimWhitespace
    autocmd!
    autocmd BufWritePre *vimrc :%s/\s\+$//e
augroup END
